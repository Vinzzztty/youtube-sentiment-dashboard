<!DOCTYPE html>
<html lang="en">
    {% include "includes/head.html" %}
    <body>
        <!-- Navbar section -->
        <section>{% include "includes/navbar.html" %}</section>

        <!-- Hero  -->
        <section class="hero">
            <div class="container">
                <h1 class="text-center heading">
                    <u>Sentiment Analysis</u> YouTube Comments
                </h1>
                <p class="text-center mt-5 mb-5">
                    We use BERT method to make Sentiment Analysis to 3 category
                    positive, negative, and neutral.
                </p>
            </div>
        </section>

        <section>
            <div class="searchbox">
                <div class="container">
                    <div class="row align-items-center">
                        <div class="col-md-6 text-center">
                            <h2>Crawl YouTube Comments</h2>
                            <h3>Make a Sentiment Analysis</h3>
                        </div>
                        <div class="col-md-6 text-center">
                            <form action="/crawl" method="POST">
                                <label for="video_id">YouTube Link ID:</label>
                                <input
                                    type="text"
                                    id="video_id"
                                    name="video_id"
                                    required
                                />
                                <label for="max_result">Maximal Results:</label>
                                <input
                                    type="number"
                                    id="max_result"
                                    name="max_result"
                                    required
                                />
                                <button type="submit">Crawl</button>
                            </form>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        {% if show_results %}
        <section class="results-section">
            <div
                class="container"
                x-data="sentimentApp()"
                x-init="fetchAndPredict()"
            >
                <div class="text-center">
                    <h1>Results</h1>
                </div>
                <div class="row">
                    <div class="col-lg-6 pt-5 mt-3">
                        <div class="text-center">
                            <h4>Wordcloud</h4>
                        </div>
                    </div>
                    <div class="col-lg-6 pt-5 mt-3">
                        <div class="text-center">
                            <h4>Chart</h4>
                            <canvas
                                id="sentimentChart"
                                width="200"
                                height="50"
                            ></canvas>
                        </div>
                    </div>
                </div>
                <section class="crawling-results">
                    <div class="row">
                        <div class="text-center">
                            <h4>Crawling YouTube Comment</h4>
                        </div>
                        <div class="col-lg-12 mt-3">
                            <div x-show="loading" class="loading-indicator">
                                Loading sentiments
                            </div>
                            <!-- Placeholder for the dynamically generated table -->
                            <!-- {{ table|safe }} would be replaced with the actual table HTML content generated by the backend -->
                            <div>{{ table|safe }}</div>
                        </div>
                    </div>
                </section>
            </div>
        </section>
        {% endif %}

        <script>
            function sentimentApp() {
                return {
                    loading: false, // Loading state indicator

                    reviews: [],

                    // ------ Fetch API and Predict ------------
                    fetchAndPredict() {
                        this.loading = true;
                        this.$nextTick(() => {
                            const reviewsTable =
                                document.querySelector(".table");
                            const reviewTexts = [
                                ...reviewsTable.querySelectorAll("tr"),
                            ]
                                .slice(1)
                                .map((tr) => {
                                    return tr.children[2].innerText; // Assuming the review text is the third column
                                });

                            // Call your API endpoint with the texts for sentiment analysis
                            fetch("/api/predict", {
                                method: "POST",
                                headers: {
                                    "Content-Type": "application/json",
                                },
                                body: JSON.stringify({ texts: reviewTexts }),
                            })
                                .then((response) => response.json())
                                .then((data) => {
                                    this.updateTableWithSentiments(
                                        reviewsTable,
                                        data.data.sentiments
                                    );
                                    this.loading = false;
                                })
                                .catch((error) => {
                                    console.error(
                                        "Error fetching and predicting:",
                                        error
                                    );
                                    this.loading = false;
                                });
                        });
                    },

                    // ----------  Update Table Sentiment ----------------------
                    updateTableWithSentiments(reviewsTable, sentiments) {
                        // Add a new column header for Sentiments if not added yet
                        const headerRow = reviewsTable.querySelector("tr");
                        const numColumns = headerRow.children.length;

                        if (numColumns === 4) {
                            const sentimentTh = document.createElement("th");
                            sentimentTh.innerText = "Sentiment";
                            headerRow.appendChild(sentimentTh);
                        }

                        // Sum the scores based on labels
                        const scoresSum = {};
                        sentiments.forEach((sentiment) => {
                            const label = sentiment[0].label;
                            const score = sentiment[0].score;
                            scoresSum[label] = (scoresSum[label] || 0) + score;
                        });

                        // Update each row with the sentiment analysis result
                        const rows = [
                            ...reviewsTable.querySelectorAll("tr"),
                        ].slice(1); // Exclude the header row
                        rows.forEach((tr, index) => {
                            const sentimentResult = sentiments[index][0];

                            // Return value in column Sentiment
                            const sentimentText = `${
                                sentimentResult.label
                            } (${sentimentResult.score.toFixed(2)})`;

                            // Check if sentiment cell already exists; if not, create it
                            if (tr.children.length === numColumns) {
                                const sentimentTd =
                                    document.createElement("td");
                                sentimentTd.innerText = sentimentText;
                                tr.appendChild(sentimentTd);
                            } else {
                                // Update existing sentiment cell
                                tr.children[numColumns].innerText =
                                    sentimentText;
                            }
                        });

                        this.updateCanvas(scoresSum);
                    },

                    updateCanvas(scoresSum) {
                        // Assuming scoresSum is an object with labels as keys and summed scores as values
                        const labels = Object.keys(scoresSum);
                        const scores = Object.values(scoresSum).map((score) =>
                            score.toFixed(2)
                        );

                        var ctx = document
                            .getElementById("sentimentChart")
                            .getContext("2d");

                        var myChart = new Chart(ctx, {
                            type: "pie",
                            data: {
                                labels: labels,
                                datasets: [
                                    {
                                        label: "Labels Sentiment Score",
                                        data: scores,
                                        backgroundColor: [
                                            "#00b530", // Solid green for positive sentiment
                                            "#ff1919", // Solid red for negative sentiment
                                            "#59524d", // Solid grey for neutral sentiment
                                        ],
                                        borderColor: [
                                            "#00b530", // Solid green border for positive sentiment
                                            "#ff1919", // Solid red border for negative sentiment
                                            "#59524d", // Solid grey border for neutral sentiment
                                        ],
                                        borderWidth: 1,
                                    },
                                ],
                            },
                            options: {
                                scales: {
                                    y: {
                                        beginAtZero: true,
                                    },
                                },
                            },
                        });
                    },
                };
            }
            class DelayedContent {
                constructor(elementId) {
                    this.element = document.getElementById(elementId);
                }

                delayContent() {
                    setTimeout(() => {
                        this.element.innerText =
                            "Delayed content after 5 seconds!";
                    }, 5000);
                }
            }

            // Create an instance of the DelayedContent class
            const delayedContent = new DelayedContent("wordcloud");

            // Call the delayContent method to initiate the delay
            delayedContent.delayContent();
        </script>

        <script
            src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/js/bootstrap.bundle.min.js"
            integrity="sha384-HwwvtgBNo3bZJJLYd8oVXjrBZt8cqVSpeBNS5n7C8IVInixGAoxmnlMuBnhbgrkm"
            crossorigin="anonymous"
        ></script>
    </body>
</html>
